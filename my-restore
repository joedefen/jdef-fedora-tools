#!/usr/bin/env python3
""" Program to run """
# pylint: disable=invalid-name,broad-exception-caught
# pylint: disable=too-many-locals,too-many-arguments

import sys
import os
import subprocess
import re
from types import SimpleNamespace
from InlineMenu import Menu

class BtrfsRestore:
    """ TBD """
    def __init__(self):
        if os.geteuid() != 0: # Re-run the script with sudo
            print('NOTE: restarting with "sudo"')
            os.execvp('sudo', ['sudo', sys.executable] + sys.argv)
        self.dry_run = False
        self.filesystems = []
        self.slash_mnt = self.get_slash_mnt()

    def do_command(self, prompts, todo=None, precmd='', once=False, force=False):
        """ TBD"""
        prompts['q'] = 'QUIT'
        while True:
            menu = Menu(prompts, str(todo) if todo else None)
            choice = menu.prompt()
            if choice == 'q':
                sys.exit(0)
            cmd = prompts[choice].strip()
            if not cmd.startswith('#'):
                if not force and self.dry_run:
                    os.system(f'echo WOULD + {precmd!r} {cmd!r}')
                else:
                    os.system(f'clear;set -x; {precmd} {cmd}')
            todo = chr(ord(choice) + 1)
            todo = todo if str(todo) in prompts else 'q'
            if once:
                return todo

    def get_slash_mnt(self):
        """ TBD """
        def slurp_file(pathname):
            with open(pathname, "r", encoding='utf-8') as fh:
                return [line.strip() for line in fh]

        rv = SimpleNamespace(device='', fstype='')
        lines = slurp_file('/proc/mounts')
        for line in lines:
            wds = re.split(r'\s+', line)
            if len(wds) >= 4:
                device, mount, fstype, = wds[0], wds[1], wds[2]
                if mount == '/mnt':
                    rv = SimpleNamespace(device=device, fstype=fstype)
                # elif mount == '/' and fstype.lower() == 'btrfs':
                    # print(f'\nALERT: BTRFS ({device}) mounted on /')
        return rv

    def select_mount(self):
        """ TBD """
        command_output = subprocess.check_output(['btrfs', 'filesystem', 'show']).decode('utf-8')
        lines = command_output.split('\n')
        self.filesystems = []
        for line in lines:
            mat = re.match(r"^Label:\s+('[^']*')", line)
            if mat:
                label = mat.group(1)
            mat = re.search(r"\bpath\s+(/dev/\S+)", line)
            if mat:
                path = mat.group(1)
                self.filesystems.append(SimpleNamespace(label=label, path=path))
        cmds, todo, mnt = {}, '-', self.slash_mnt
        for idx, fs in enumerate(self.filesystems):
            if fs.path == mnt.device:
                cmd = f'# KEEP {fs.path!r} mounted on /mnt'
            else:
                cmd = 'umount /dev && ' if mnt.device else ''
                cmd += f'mount {fs.path} /mnt # {fs.label}'
            cmds[str(idx)] = cmd
            todo = '0'
        self.do_command(cmds, todo, once=True, force=True)

    def select_restores(self, todo='a'):
        """ TBD """
        # pylint: disable=too-many-branches
        os.chdir('/mnt')
        command_output = subprocess.check_output([
            'btrfs', 'sub', 'list', '.']).decode('utf-8')
        lines = command_output.split('\n')
        snaps = {}
        for line in lines:
            mat = re.search(r"\bpath\s+(\S+)", line)
            if not mat:
                continue
            subpath = mat.group(1)
            wds = subpath.split('/')
            if len(wds) > 1 and wds[-2].startswith('.snapshots'):
                try:
                    subvol, _ = wds[-1].rsplit('.', maxsplit=1)
                    snaps[subpath] = subvol
                except Exception:
                    pass
        # print(f'{snaps=} {subs=} {prevs=}')
        cmds = {}
        skips = set()
        idx = 'a'
        snaps = {k: snaps[k] for k in sorted(snaps)}
        for snap_path, subvol in snaps.items():
            subvol = snaps[snap_path]
            if subvol in skips:
                continue
            has_old = os.path.exists(f'{subvol}.old')
            has_new = os.path.exists(f'{subvol}.new')
            if not os.path.exists(f'{subvol}'):
                cmds[str(idx)] = f'# ERR: {subvol} does NOT exist'
                skips.add(subvol)
            elif has_old and has_new:
                cmds[str(idx)] = f'# ERR: {subvol}.old AND {subvol}.new exists'
                skips.add(subvol)
            elif os.path.exists(f'{subvol}.old'):
                cmds[str(idx)] = (f'echo RE-RESTORE "{subvol}" && '
                    f'mv "{subvol}" "{subvol}.new" && mv "{subvol}.old" "{subvol}"')
                skips.add(subvol)
            elif os.path.exists(f'{subvol}.new'):
                cmds[str(idx)] = (f'echo UN-RESTORE "{subvol}" && '
                    f'mv "{subvol}" "{subvol}.old" && mv "{subvol}.new" "{subvol}"')
                skips.add(subvol)
            else:
                basename = os.path.basename(snap_path)
                cmds[idx] = (f'echo RESTORE "{basename}" && '
                    f'btrfs sub snap "{snap_path}" "{subvol}.old" && '
                        + f'mv "{subvol}" "{subvol}.new" && mv "{subvol}.old" "{subvol}"')
            idx = chr(ord(idx) + 1)
        cmds[idx] = 'reboot now'
        return self.do_command(cmds, once=True, todo=todo)

    def main(self):
        """ The top-level function. """
        # pylint: disable=import-outside-toplevel
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('-n', '--dry-run', action="store_true",
                help='do NOT do anything')
        opts = parser.parse_args()
        self.dry_run = opts.dry_run
        self.select_mount()
        os.system('clear')
        todo = 'a'
        while True:
            todo = self.select_restores(todo=todo)

BtrfsRestore().main()
