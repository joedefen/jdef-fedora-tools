#!/usr/bin/env python3
""" Program to run """
# pylint: disable=invalid-name,broad-exception-caught
# pylint: disable=too-many-locals,too-many-arguments

import sys
import os
import subprocess
import re
from types import SimpleNamespace
from InlineMenu import Menu

class BtrfsRestore:
    """ TBD """
    def __init__(self):
        if os.geteuid() != 0: # Re-run the script with sudo
            print('NOTE: restarting with "sudo"')
            os.execvp('sudo', ['sudo', sys.executable] + sys.argv)
        self.dry_run = False
        self.filesystems = []
        self.slash_mnt = self.get_slash_mnt()

    def do_command(self, prompts, todo=None, precmd='', once=False, force=False):
        """ TBD"""
        prompts['x'] = 'EXIT'
        while True:
            menu = Menu(prompts, str(todo) if todo else None)
            choice = menu.get_prompt_obj()
            if choice.key == 'x':
                sys.exit(0)
            cmd = menu.get_command(choice)
            if not cmd.startswith('#'):
                if not force and self.dry_run:
                    os.system(f'echo WOULD + {precmd!r} {cmd!r}')
                else:
                    os.system(f'clear;set -x; {precmd} {cmd}')
            todo = choice.next
            if once:
                return todo

    def get_slash_mnt(self):
        """ TBD """
        def slurp_file(pathname):
            with open(pathname, "r", encoding='utf-8') as fh:
                return [line.strip() for line in fh]

        rv = SimpleNamespace(device='', fstype='')
        lines = slurp_file('/proc/mounts')
        for line in lines:
            wds = re.split(r'\s+', line)
            if len(wds) >= 4:
                device, mount, fstype, = wds[0], wds[1], wds[2]
                if mount == '/mnt':
                    rv = SimpleNamespace(device=device, fstype=fstype)
                # elif mount == '/' and fstype.lower() == 'btrfs':
                    # print(f'\nALERT: BTRFS ({device}) mounted on /')
        return rv

    def select_mount(self):
        """ TBD """
        command_output = subprocess.check_output(['btrfs', 'filesystem', 'show']).decode('utf-8')
        lines = command_output.split('\n')
        self.filesystems = []
        for line in lines:
            mat = re.match(r"^Label:\s+('[^']*')", line)
            if mat:
                label = mat.group(1)
            mat = re.search(r"\bpath\s+(/dev/\S+)", line)
            if mat:
                path = mat.group(1)
                self.filesystems.append(SimpleNamespace(label=label, path=path))
        cmds, todo, mnt = {}, '-', self.slash_mnt
        for idx, fs in enumerate(self.filesystems):
            if fs.path == mnt.device:
                cmd = f'# KEEP {fs.path!r} mounted on /mnt'
            else:
                cmd = 'umount /dev && ' if mnt.device else ''
                cmd += f'mount {fs.path} /mnt # {fs.label}'
            cmds[str(idx)] = cmd
            todo = '0'
        todo = self.do_command(cmds, todo, once=True, force=True)

    def select_restores(self, todo='a'):
        """ TBD """
        # pylint: disable=too-many-branches
        os.chdir('/mnt')
        command_output = subprocess.check_output([
            'btrfs', 'sub', 'list', '.']).decode('utf-8')
        lines = command_output.split('\n')
        snaps = {}
        for line in lines:
            mat = re.search(r"\bpath\s+(\S+)", line)
            if not mat:
                continue
            subpath = mat.group(1)
            wds = subpath.split('/')
            if len(wds) > 1 and wds[-2].endswith('@snapshots'):
                try:
                    subvol, _ = wds[-1].rsplit('.', maxsplit=1)
                    snaps[subpath] = subvol
                except Exception:
                    pass
        print(f'{snaps=}')
        cmds = {}
        skips = set()
        key = 'a'
        snaps = {k: snaps[k] for k in sorted(snaps)}
        for snap_path, subvol in snaps.items():
            subvol = snaps[snap_path]
            if subvol in skips:
                continue
            has_old = os.path.exists(f'{subvol}.OLD')
            has_new = os.path.exists(f'{subvol}.NEW')
            if not os.path.exists(f'{subvol}'):
                cmds[key] = f'# ERR: {subvol} does NOT exist'
                skips.add(subvol)
            elif has_old and has_new:
                cmds[key] = f'# ERR: {subvol}.OLD AND {subvol}.NEW exists'
                skips.add(subvol)
            elif os.path.exists(f'{subvol}.OLD'):
                cmds[key] = [f'RE-RESTORE: {subvol}',
                    f'mv "{subvol}" "{subvol}.NEW" && mv "{subvol}.OLD" "{subvol}"']
                skips.add(subvol)
            elif os.path.exists(f'{subvol}.NEW'):
                cmds[key] = [f'UN-RESTORE: {subvol}',
                    f'mv "{subvol}" "{subvol}.OLD" && mv "{subvol}.NEW" "{subvol}"']
                skips.add(subvol)
            else:
                basename = os.path.basename(snap_path)
                cmds[key] = [f'RESTORE: {basename}',
                    f'btrfs sub snap "{snap_path}" "{subvol}.OLD" && '
                        f'mv "{subvol}" "{subvol}.NEW" && mv "{subvol}.OLD" "{subvol}"']
            key = Menu.get_next_key(key)
        cmds[key] = 'reboot now'
        return self.do_command(cmds, once=True, todo=todo)

    def main(self):
        """ The top-level function. """
        # pylint: disable=import-outside-toplevel
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('-n', '--dry-run', action="store_true",
                help='do NOT do anything')
        opts = parser.parse_args()
        self.dry_run = opts.dry_run
        self.select_mount()
        os.system('clear')
        todo = 'a'
        while True:
            todo = self.select_restores(todo=todo)

BtrfsRestore().main()
